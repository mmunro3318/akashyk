# Product Design Document: Akashyk

**Project Title:** Akashyk - An AI Memory Repository  
**Version:** 1.0  
**Author:** Michael Munro
**Date:** August 19, 2025

## 1. Problem Statement

Modern AI models lack a centralized, persistent long-term memory. Users must manually copy and paste relevant information from past conversations or documents into new chats to provide context. This is inefficient, tedious, and leads to a fragmented knowledge base.

## 2. Solution Overview

Akashyk is a web application that serves as a centralized, AI-powered repository for a user's conversations, documents, and images. It provides a single source of truth that can be accessed and utilized by multiple AI models. The core functionality includes a secure portal for content ingestion, an AI-driven system for organization and summarization, and a robust API for AI models to retrieve relevant information.

## 3. Technical Stack

- **Frontend:** Next.js (using the App Router), TypeScript, Tailwind CSS
- **Backend & Database:** Supabase (PostgreSQL, Auth, Storage, and Edge Functions)
- **AI Integration:** API calls to external AI models (e.g., OpenAI, Hugging Face, etc.)

## 4. Epochs & Core Features

We will build Akashyk in three distinct epochs, ensuring a stable foundation before adding more complex features.

### Epoch 1: The Core Repository (Foundation)

This epoch focuses on building a secure, functional data repository and a basic user interface.

**User Stories:**

- As a user, I can securely sign up and log in to the application
- As a user, I can manually add new memories, including text, documents, or images
- As a user, I can view a list of all the memories I have added
- As a user, I can perform a basic keyword search to find specific memories

**Technical Breakdown:**

- **Next.js Setup:** Initialize a Next.js project with TypeScript and Tailwind CSS
- **Supabase Setup:** Create a Supabase project and set up a `memories` table
  - `memories` table columns: `id`, `user_id`, `type`, `title`, `content`, `file_url`, `created_at`
- **Authentication:** Implement user sign-up and sign-in using Supabase Auth
- **Security:** Configure Row Level Security (RLS) on the `memories` table to ensure that a user can only access their own data
- **UI:** Build a minimal user interface with a login/sign-up form and a form for adding new memories

### Epoch 2: AI-Powered Organization & Summarization

This epoch integrates AI to make the repository intelligent and highly searchable.

**User Stories:**

- As a user, when I add a new memory, an AI automatically generates a summary and extracts key concepts
- As a user, I want the AI to organize my memories into high-level directories based on content similarity
- As a user, I want to be able to use a natural language query to find relevant memories (e.g., "Find my conversations about Next.js and Supabase")

**Technical Breakdown:**

- **AI Integration:** Connect the Next.js app to an AI model API
- **Data Processing:** Implement a workflow to send new content to the AI. This could be done via a Next.js API route or a Supabase Edge Function
- **Database Enhancement:** Add columns to the `memories` table to store AI-generated summaries, keywords, and vector embeddings
  - Use Supabase's built-in pgvector extension to create and store these embeddings, which are essential for semantic search
- **Automated Workflow:** Implement a trigger or webhook that fires every time a new memory is created, initiating the AI processing

### Epoch 3: The AI-Facing API & Enhanced UI

This epoch builds the primary interface for other AI models to use Akashyk and refines the user's experience.

**User Stories:**

- As an external AI model, I can send a query to an Akashyk API and receive a list of highly relevant memories
- As a user, I can view a dashboard that displays the AI-generated directory structure and high-level summaries of all my memories
- As a user, I can use an advanced search interface that understands the meaning behind my queries

**Technical Breakdown:**

- **Retrieval API:** Design and build a secure API endpoint in Next.js that takes a query, performs a semantic search on the vector embeddings in Supabase, and returns the top-N results
- **Enhanced UI:**
  - Create a dashboard page that dynamically renders the directory structure generated by the AI
  - Build an advanced search component that sends user queries to the new retrieval API
  - Implement a clean display for viewing individual memories, including the AI-generated summary and source content

## 5. Assumptions & Constraints

- **Single User:** The application is designed for a single user to manage their personal memories
- **Additive Only:** The initial design focuses on adding content. The ability to edit or delete memories is a future consideration
- **Publicly Accessible API:** The AI-facing API will be publicly accessible but will require a secure key or token for access
